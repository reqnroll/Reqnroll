<Project>

  <PropertyGroup>
    <ReqnrollCompatibilityVersionRange>[$(PackageVersion),$(CompatibilityVersionUpperRange))</ReqnrollCompatibilityVersionRange>
    <PackagesOutputPath>$(MSBuildThisFileDirectory)GeneratedNuGetPackages\$(Configuration)</PackagesOutputPath>
  </PropertyGroup>

  <!-- Copies generated NuGet packages and symbol packages to the output packages path -->
  <Target
    Name="CopyPackageToPackagesOutputPath"
    AfterTargets="Pack">
    <ItemGroup>
      <GeneratedPackages Include="$(PackageOutputAbsolutePath)\*.*nupkg"/>
    </ItemGroup>
    <Copy SourceFiles="@(GeneratedPackages)" DestinationFolder="$(PackagesOutputPath)" />
  </Target>

  <UsingTask
    TaskName="ReqnrollClearNuGetCache"
    TaskFactory="RoslynCodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
    <ParameterGroup>
      <NuGetCacheDirectory ParameterType="System.String" Required="true" />
      <EnsureNugetCacheCleared ParameterType="System.String" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System"/>
      <Using Namespace="System.IO"/>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
string TmpDirectory = NuGetCacheDirectory + "-remove";

Log.LogMessage("Cleaning local nuget cache " + NuGetCacheDirectory);

if (Directory.Exists(TmpDirectory)) 
{
    try 
    {
        Directory.Delete(TmpDirectory, true);
    }
    catch 
    {
        Log.LogError("Can't start cleaning NuGet Cache Directory, deleting temporary directory failed: " + NuGetCacheDirectory);
    }
}    
if (Directory.Exists(NuGetCacheDirectory))
{
    try
    {
        // If a file is locked, calling Directory.Delete can result in half-removed directories.
        // This is bad for nuget caches, as dotnet restore may fail in these cases.
        // That's why we first move the directory (which is only possible if no file is locked in the directory) and then delete the renamed directory.
        Directory.Move(NuGetCacheDirectory, TmpDirectory);
    }
    catch (Exception ex)
    {
        if (EnsureNugetCacheCleared != "false")
            Log.LogError("Can't clean NuGet Cache Directory " + NuGetCacheDirectory + ". Set REQNROLL_ENSURE_NUGET_CACHE_CLEARED to false to handle this error as a warning. " + ex.Message);
        else
            Log.LogWarning("Can't clean NuGet Cache Directory " + NuGetCacheDirectory);
    }
}
if (Directory.Exists(TmpDirectory)) 
{
    try 
    {
        Directory.Delete(TmpDirectory, true);
    }
    catch 
    {
        Log.LogWarning("Can't finish cleaning NuGet Cache Directory, deleting temporary directory failed: " + NuGetCacheDirectory);
    }
}    
]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="DeleteLocalNuGetCache" BeforeTargets="Pack" Condition="$(VersionSuffix)=='local'">
    <!--Clears the NuGet cache manually until https://github.com/NuGet/Home/issues/5713 is fixed.-->
    <!--Implementation based on https://www.nyckel.com/blog/nuget-packages/.-->
    <ReqnrollClearNuGetCache NuGetCacheDirectory="$(NugetPackageRoot)/$(PackageId.ToLower())/$(VersionPrefix)-$(VersionSuffix)" EnsureNugetCacheCleared="$(REQNROLL_ENSURE_NUGET_CACHE_CLEARED)"/>
  </Target>

  <!-- Get the list of project reference outputs that should be packed as part of this package. -->
  <Target
    Name="_GetProjectReferenceCopyLocalPathsForPackAsComponent"
    DependsOnTargets="ResolveReferences"
    Returns="_ProjectReferenceCopyLocalPathsForPackAsComponent">

    <ItemGroup>
      <_ReferenceCopyLocalProjects
        Include="@(ReferenceCopyLocalPaths -> '%(ProjectReferenceOriginalItemSpec)')"
        Condition="'%(ReferenceCopyLocalPaths.ReferenceSourceTarget)' == 'ProjectReference' AND '%(ReferenceCopyLocalPaths.PackAsComponent)' == 'true'">
        <Asset>%(Identity)</Asset>
      </_ReferenceCopyLocalProjects>
    </ItemGroup>

    <ItemGroup>
      <_ProjectReferenceCopyLocalPathsForPackAsComponent
        Include="@(_ReferenceCopyLocalProjects->'%(Asset)')"
        Condition="'%(ProjectReference.PackAsComponent)' == 'true'"/>
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <TargetsForTfmSpecificContentInPackage>
      $(TargetsForTfmSpecificContentInPackage);
      CollectProjectReferenceOutputsForPack
    </TargetsForTfmSpecificContentInPackage>
    
    <CollectProjectReferenceOutputsForPackDependsOn>
      $(CollectProjectReferenceOutputsForPackDependsOn);
      _GetProjectReferenceCopyLocalPathsForPackAsComponent
    </CollectProjectReferenceOutputsForPackDependsOn>
  </PropertyGroup>

  <!-- Include referenced project assembly as part of this package directly. -->
  <Target Name="CollectProjectReferenceOutputsForPack" DependsOnTargets="$(CollectProjectReferenceOutputsForPackDependsOn)">
    <ItemGroup>
      <TfmSpecificPackageFile
        Include="@(_ProjectReferenceCopyLocalPathsForPackAsComponent)"
        PackagePath="lib/$(TargetFramework)/"
        Condition="'%(Extension)' != '.pdb'"/>
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <TargetsForTfmSpecificDebugSymbolsInPackage>
      $(TargetsForTfmSpecificDebugSymbolsInPackage);
      CollectProjectReferenceDebugSymbolsForPack
    </TargetsForTfmSpecificDebugSymbolsInPackage>

    <CollectProjectReferenceDebugSymbolsForPackDependsOn>
      $(CollectProjectReferenceDebugSymbolsForPackDependsOn);
      _GetProjectReferenceCopyLocalPathsForPackAsComponent
    </CollectProjectReferenceDebugSymbolsForPackDependsOn>
  </PropertyGroup>

  <!-- Included referenced project PDBs as part of the symbols package. -->
  <Target Name="CollectProjectReferenceDebugSymbolsForPack" DependsOnTargets="$(CollectProjectReferenceDebugSymbolsForPackDependsOn)">
    <ItemGroup>
      <TfmSpecificDebugSymbolsFile
        Include="@(_ProjectReferenceCopyLocalPathsForPackAsComponent)"
        Condition="'%(Extension)' == '.pdb'"/>
    </ItemGroup>

    <ItemGroup>
      <_TfmSpecificDebugSymbolsCandidate
        Include="@(_ProjectReferenceCopyLocalPathsForPackAsComponent->'%(RootDir)%(Directory)%(Filename).pdb')"
        Condition="'%(Extension)' != '.pdb'"/>
      <TfmSpecificDebugSymbolsFile
        Include="@(_TfmSpecificDebugSymbolsCandidate)"
        TargetFramework="$(TargetFramework)"
        Condition="Exists('%(FullPath)')" />
    </ItemGroup>
  </Target>
  
</Project>