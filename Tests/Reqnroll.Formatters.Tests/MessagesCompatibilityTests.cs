using System.Diagnostics;
using System.Reflection;

namespace Reqnroll.Formatters.Tests;

[DoNotParallelize]
[TestClass]
public class MessagesCompatibilityTests : MessagesCompatibilityTestBase
{
    [TestMethod]
    [DataRow("ambiguous")]
    [DataRow("backgrounds")]
    [DataRow("cdata")]
    [DataRow("data-tables")]
    [DataRow("doc-strings")]
    [DataRow("empty")]
    [DataRow("examples-tables")]
    [DataRow("examples-tables-attachment")]
    [DataRow("examples-tables-undefined")]
    [DataRow("global-hooks")]
    [DataRow("hooks")]
    [DataRow("hooks-attachment")]
    [DataRow("hooks-conditional")]
    [DataRow("hooks-named")] // This works b/c we ignore the name property when comparing
    [DataRow("hooks-undefined")]
    [DataRow("minimal")]
    [DataRow("multiple-features")]
    [DataRow("parameter-types")]
    [DataRow("pending")]
    [DataRow("rules")]
    [DataRow("rules-backgrounds")]
    [DataRow("skipped")]
    [DataRow("stack-traces")]
    [DataRow("undefined")] // Snippet provider does not provide all variations possible of method signatures
    [DataRow("unused-steps")]
    
    // These CCK scenario examples produce Cucumber Messages that are materially compliant with the CCK.
    // The messages produced match the CCK expected messages, with exceptions for things
    // that are not material to the CCK spec (such as IDs don't have to be generated in the same order, timestamps don't have to match, etc.)
    // The rules for what must match and what is allowed to not match are built in to a series of custom FluentAssertion validation rules
    // (located in the CucumberMessagesValidator class)
    public void CCKScenarios(string testName)
    { 
        var featureFileName = testName.Replace("-", "_");
        ResetCucumberMessages(featureFileName);
        ResetCucumberMessagesHtml(featureFileName);
        EnableCucumberMessages();
        SetCucumberMessagesOutputFileName(featureFileName);

        CucumberMessagesAddConfigurationFile("reqnroll_withBothFormatters.json");
        MimicAzurePipelinesEnvironment();
        AddUtilClassWithFileSystemPath();

        AddFeatureFilesFromResources(featureFileName, "Samples", Assembly.GetExecutingAssembly());
        AddBindingClassFromResource($"{featureFileName}/{featureFileName}.cs", "Samples", Assembly.GetExecutingAssembly());

        ExecuteTests();
        var actualResults = GetActualResults(featureFileName).ToArray();
        var validator = new CucumberMessagesValidator(actualResults, GetExpectedResults(featureFileName).ToArray());
        validator.ShouldPassBasicStructuralChecks();
        validator.ResultShouldPassAllComparisonTests();
        validator.ResultShouldPassSanityChecks();

        // Validate that the generated html, if present, has a line of text that includes all the ACTUAL envelope messages
        // We're not validating that envelope generation succeeded (that was already tested); we're validating that those generated messages
        // made their way into the HTML
        var generatedHtml = GetActualGeneratedHtml(featureFileName);
        var actualMessagesJson = GetActualJsonText(featureFileName);
        var htmlValidator = new CucumberMessagesHtmlGenerationValidator(generatedHtml, actualMessagesJson);
        htmlValidator.GeneratedHtmlProperlyReflectsExpectedMessages();

        // This is necessary b/c the System Test framework doesn't understand Rules and can't determine the number of expected tests
        // HACK: Hardcoded values; might need to change should the CCK change these scenarios:
        // The 'Rules' scenario has 3 tests
        // The 'RulesBackground' scenario has 2 tests
        int? numOfTests = null;
        if (testName == "rules")
            numOfTests = 3;
        if (testName == "rules-backgrounds")
            numOfTests = 2;
        ConfirmAllTestsRan(numOfTests);
    }

    [Ignore]
    [TestMethod]
    // These tests are not (yet) within the CCK but are included here to round out the testing. The expected results were generated by the CucumberMessages plugin.
    // Once the CCK includes these scenarios, the expected results should come from the CCK repo.
    public void NonCCKScenarios(string testName)
    {
        CCKScenarios(testName);
    }

    [Ignore]
    [TestMethod]
    [DataRow("attachments")] // Reqnroll does not support user-supplied mime-types for attachments or providing mime-types to WriteLine output
    [DataRow("global-hooks-beforeall-error")] // Cucumber expects execution to continue after a hook failure
    [DataRow("global-hooks-afterall-error")] // Cucumber expects execution to continue after a hook failure
    [DataRow("global-hooks-attachments")] // Fails b/c we cannot obtain Reqnroll OutputHandler in global hooks
    [DataRow("unknown-parameter-type")] // Reqnroll does not provide skeletons for missing Parameter Types
    [DataRow("regular-expression")] // Reqnroll does not support optional binding method arguments
    [DataRow("multiple-features-reversed")] // Reqnroll does not have the concept of specifying execution order via run-time parameter
    // These scenarios are from the CCK, but Reqnroll cannot provide a compliant implementation. This is usually the result of differences in behavior or support of Gherkin features.
    // When these scenarios are run, expect them to fail.
    public void NonCompliantCCKScenarios(string testName)
    {
        CCKScenarios(testName);
    }

    [TestMethod]
    //[DataRow("xRetry")] // xRetry currently fails this test because it retries a scenario with an undefined step (which is not expected behavior)
    [DataRow("NUnitRetry", "retry")] // The feature-file and expected result .ndjson file have been modified from the CCK to reflect that NUnitRetry uses a Feature-level tag
    [DataRow("NUnitRetry", "retry-ambiguous")]
    [DataRow("NUnitRetry", "retry-pending")]
    [DataRow("NUnitRetry", "retry-undefined")]
    // When this test suite is refreshed from the CCK, these changes need to be re-applied for this test to properly operate and pass.
    // These tests attempt to execute the Retry scenario from the CCK using the known open-source plugins for Reqnroll that integrate Retry functionality into Reqnroll.
    public void CCKRetryScenario(string pluginName, string testNameRoot)
    {
        var (plugin, version, unitTestProvider) = pluginName switch
        {
            "NUnitRetry" => ("NUnitRetry.ReqnrollPlugin", "1.0.100", TestProjectGenerator.UnitTestProvider.NUnit4),
            "xRetry" => ("xRetry.Reqnroll", "1.0.0", TestProjectGenerator.UnitTestProvider.xUnit),
            _ => throw new NotImplementedException("unknown plugin name")
        };

        _testRunConfiguration.UnitTestProvider = unitTestProvider;
        _projectsDriver.AddNuGetPackage(plugin, version);
        var testName = $"{pluginName}-{testNameRoot}";
        CCKScenarios(testName);
    }
}