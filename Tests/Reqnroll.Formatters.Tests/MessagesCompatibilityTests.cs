using System.Reflection;

namespace Reqnroll.Formatters.Tests;

[TestClass]
public class MessagesCompatibilityTests : MessagesCompatibilityTestBase
{
    [TestMethod]
    [DataRow("ambiguous")]
    [DataRow("backgrounds")]
    [DataRow("doc-strings")]
    [DataRow("minimal")]
    [DataRow("cdata")]
    [DataRow("data-tables")]
    [DataRow("pending")]
    [DataRow("empty")]
    [DataRow("examples-tables")]
    [DataRow("examples-tables-attachment")]
    [DataRow("global-hooks")]
    [DataRow("hooks")]
    [DataRow("hooks-attachment")]
    [DataRow("hooks-conditional")]
    [DataRow("parameter-types")]
    [DataRow("rules")]
    [DataRow("rules-backgrounds")]
    [DataRow("skipped")]
    [DataRow("stack-traces")]
    [DataRow("unused-steps")]
    [DataRow("undefined")] // Snippet provider does not provide all variations possible of method signatures
    
    // These CCK scenario examples produce Cucumber Messages that are materially compliant with the CCK.
    // The messages produced match the CCK expected messages, with exceptions for things
    // that are not material to the CCK spec (such as IDs don't have to be generated in the same order, timestamps don't have to match, etc.)
    // The rules for what must match and what is allowed to not match are built in to a series of custom FluentAssertion validation rules
    // (located in the CucumberMessagesValidator class)
    public void CCKScenarios(string testName)
    {
        var featureFileName = testName.Replace("-", "_");
        ResetCucumberMessages(featureFileName);
        ResetCucumberMessagesHtml(featureFileName);
        EnableCucumberMessages();
        SetCucumberMessagesOutputFileName(featureFileName);

        CucumberMessagesAddConfigurationFile("reqnroll_withBothFormatters.json");
        MimicAzurePipelinesEnvironment();
        AddUtilClassWithFileSystemPath();


        AddFeatureFileFromResource($"{featureFileName}/{featureFileName}.feature", "Samples", Assembly.GetExecutingAssembly());
        AddBindingClassFromResource($"{featureFileName}/{featureFileName}.cs", "Samples", Assembly.GetExecutingAssembly());

        ExecuteTests();
        var actualResults = GetActualResults(featureFileName).ToArray();
        var validator = new CucumberMessagesValidator(actualResults, GetExpectedResults(featureFileName).ToArray());
        validator.ShouldPassBasicStructuralChecks();
        validator.ResultShouldPassAllComparisonTests();
        validator.ResultShouldPassSanityChecks();

        // Validate that the generated html, if present, has a line of text that includes all the ACTUAL envelope messages
        // We're not validating that envelope generation succeeded (that was already tested); we're validating that those generated messages
        // made their way into the HTML
        var generatedHtml = GetActualGeneratedHtml(featureFileName);
        var actualMessagesJson = GetActualJsonText(featureFileName);
        var htmlValidator = new CucumberMessagesHtmlGenerationValidator(generatedHtml, actualMessagesJson);
        htmlValidator.GeneratedHtmlProperlyReflectsExpectedMessages();

        // This is necessary b/c the System Test framework doesn't understand Rules and can't determine the number of expected tests
        ConfirmAllTestsRan(testName == "rules" ? 3 : null);
    }

    [TestMethod]
    // These tests are not (yet) within the CCK but are included here to round out the testing. The expected results were generated by the CucumberMessages plugin.
    // Once the CCK includes these scenarios, the expected results should come from the CCK repo.
    public void NonCCKScenarios(string testName)
    {
        CCKScenarios(testName);
    }

    //[Ignore]
    [TestMethod]
    [DataRow("attachments")]
    [DataRow("global-hooks-beforeall-error")]
    [DataRow("global-hooks-afterall-error")]
    [DataRow("global-hooks-attachments")]
    [DataRow("hooks-named")]
    [DataRow("unknown-parameter-type")]
    [DataRow("regular-expression")]
    // These scenarios are from the CCK, but Reqnroll cannot provide a compliant implementation. This is usually the result of differences in behavior or support of Gherkin features.
    // When these scenarios are run, expect them to fail.
    public void NonCompliantCCKScenarios(string testName)
    {
        CCKScenarios(testName);
    }

    [TestMethod]
    //[DataRow("xRetry")] // xRetry currently fails this test because it retries a scenario with an undefined step (which is not expected behavior)
    [DataRow("NUnitRetry")] // The feature-file and expected result .ndjson file have been modified from the CCK to reflect that NUnitRetry uses a Feature-level tag
    // When this test suite is refreshed from the CCK, these changes need to be re-applied for this test to properly operate and pass.
    // These tests attempt to execute the Retry scenario from the CCK using the known open-source plugins for Reqnroll that integrate Retry functionality into Reqnroll.
    public void CCKRetryScenario(string pluginName)
    {
        var (plugin, version, unitTestProvider) = pluginName switch
        {
            "NUnitRetry" => ("NUnitRetry.ReqnrollPlugin", "1.0.100", TestProjectGenerator.UnitTestProvider.NUnit4),
            "xRetry" => ("xRetry.Reqnroll", "1.0.0", TestProjectGenerator.UnitTestProvider.xUnit),
            _ => throw new NotImplementedException("unknown plugin name")
        };

        _testRunConfiguration.UnitTestProvider = unitTestProvider;
        _projectsDriver.AddNuGetPackage(plugin, version);
        var testName = $"retry_{pluginName}";
        CCKScenarios(testName);
    }
}