using System.Reflection;
using Reqnroll.TestProjectGenerator;

namespace CucumberMessages.Tests
{
    [TestClass]
    public class CucumberCompatibilityTests : CucumberCompatibilityTestBase
    {

        [TestMethod]
        [DataRow("minimal", "minimal")]
        [DataRow("cdata", "cdata")]
        [DataRow("pending", "Pending steps")]
        [DataRow("empty", "Empty Scenarios")]
        [DataRow("examples-tables", "Examples Tables")]
        [DataRow("examples-tables-attachment", "Examples Tables - With attachments")]
        [DataRow("data-tables", "Data Tables")]
        [DataRow("hooks", "Hooks")]
        [DataRow("hooks-attachment", "Hooks - Attachments")]
        [DataRow("hooks-conditional", "Hooks - Conditional execution")]
        [DataRow("parameter-types", "Parameter Types")]
        [DataRow("undefined", "Undefined steps")]
        [DataRow("stack-traces", "Stack traces")]
        [DataRow("rules", "Usage of a `Rule`")]
        // These CCK scenario examples produce Cucumber Messages that are materially compliant with the CCK.
        // The messages produced match the CCK expected messages, with exceptions for things
        // that are not material to the CCK spec (such as IDs don't have to be generated in the same order, timestamps don't have to match, etc.)
        // The rules for what must match and what is allowed to not match are built in to a series of custom FluentAssertion validation rules
        // (located in the CucumberMessagesValidator class)
        public void CCKScenarios(string testName, string featureNameText)
        {
            ResetCucumberMessages(featureNameText);
            EnableCucumberMessages();
            SetCucumberMessagesOutputFileName(featureNameText);

            CucumberMessagesAddConfigurationFile("reqnroll.json");
            AddUtilClassWithFileSystemPath();

            var featureFileName = testName.Replace("-", "_");

            AddFeatureFileFromResource($"{featureFileName}/{featureFileName}.feature", "Samples", Assembly.GetExecutingAssembly());
            AddBindingClassFromResource($"{featureFileName}/{featureFileName}.cs", "Samples", Assembly.GetExecutingAssembly());

            ExecuteTests();
            var actuals = GetActualResults(testName, featureNameText).ToList();
            var validator = new CucumberMessagesValidator(actuals, GetExpectedResults(testName, featureFileName).ToList());
            validator.ShouldPassBasicStructuralChecks();
            validator.ResultShouldPassAllComparisonTests();
            validator.ResultShouldPassSanityChecks();

            // Validate that the generated html, if present, has a line of text that includes all of the ACTUAL envelope messages
            // We're not validating that envelope generation succeeded (that was already tested); we're validating that those generated messages
            // made their way into the HTML
            var generatedHtml = GetActualGeneratedHTML(testName, featureNameText);
            var actualsMessagesJson = GetActualsJsonText(testName, featureNameText);
            var htmlValidator = new CucumberMessagesHTMLGenerationValidator(generatedHtml, actualsMessagesJson);
            htmlValidator.GeneratedHtmlProperlyReflectsExpectedMessages();

            // This is necessary b/c the System Test framework doesn't understand Rules and can't determine the number of expected tests
            ConfirmAllTestsRan(testName == "rules" ? 3 : null);
        }

        [TestMethod]
        [DataRow("ambiguous", "ambiguous")]
        [DataRow("background", "background")]
        [DataRow("test-run-hooks", "Test Run Hooks")] //TODO: This test is passing but really shouldn't as it is not emitting the user's BeforeTestRun hook Started/Finished messages
        // These tests are not (yet) within the CCK but are included here to round out the testing. The expected results were generated by the CucumberMessages plugin.
        // Once the CCK includes these scenarios, the expected results should come from the CCK repo.
        public void NonCCKScenarios(string testName, string featureNameText)
        {
            CCKScenarios(testName, featureNameText);
        }

        [Ignore]
        [TestMethod]
        [DataRow("attachments", "Attachments")]
        [DataRow("hooks-named", "Hooks - Named")]
        [DataRow("skipped", "Skipping scenarios")]
        [DataRow("unknown-parameter-type", "Unknown Parameter Types")]
        // These scenarios are from the CCK, but Reqnroll cannot provide a compliant implementation. This is usually the result of differences in behavior or support of Gherkin features.
        // When these scenarios are run, expect them to fail.
        public void NonCompliantCCKScenarios(string testName, string featureNameText)
        {
            CCKScenarios(testName, featureNameText);
        }

        [TestMethod]
        //[DataRow("xRetry")] // xRetry currently fails this test because it retries a scenario with an undefined step (which is not expected behavior)
        [DataRow("NUnitRetry")] // The feature-file and expected result .ndjson file have been modified from the CCK to reflect that NUnitRetry uses a Feature-level tag
                                // When this test suite is refreshed from the CCK, these changes need to be re-applied for this test to properly operate and pass.
        // These tests attempt to execute the Retry scenario from the CCK using the known open-source plugins for Reqnroll that integrate Retry functionality into Reqnroll.
        public void CCKRetryScenario(string pluginName)
        {
            var (plugin, version, unitTestProvider) = pluginName switch
            {
                "NUnitRetry" => ("NUnitRetry.ReqnrollPlugin", "1.0.100", UnitTestProvider.NUnit4),
                "xRetry" => ("xRetry.Reqnroll", "1.0.0", UnitTestProvider.xUnit),
                _ => throw new NotImplementedException("unknown plugin name")
            };

            _testRunConfiguration.UnitTestProvider = unitTestProvider;
            _projectsDriver.AddNuGetPackage(plugin, version);
            var testName = $"retry-{pluginName}";
            CCKScenarios(testName, testName);

        }
    }

}