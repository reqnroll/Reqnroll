using Io.Cucumber.Messages.Types;
using Microsoft.VisualStudio.TestPlatform.PlatformAbstractions;
using Newtonsoft.Json.Bson;
using Reqnroll;
using System.Reflection;
using FluentAssertions;
using System.Text.Json;
using System.ComponentModel;
using Reqnroll.TestProjectGenerator;
using Microsoft.VisualStudio.TestPlatform.ObjectModel.Client;
using Reqnroll.TestProjectGenerator.Driver;
using Moq;
using Reqnroll.Tracing;
using Reqnroll.EnvironmentAccess;
using Microsoft.VisualBasic.FileIO;
using Reqnroll.CucumberMessages.PayloadProcessing;
using Reqnroll.CommonModels;
using Reqnroll.CucumberMessages.Configuration;

namespace CucumberMessages.Tests
{
    [TestClass]
    public class CucumberCompatibilityTests : CucumberCompatibilityTestBase
    {

        [TestMethod]
        [DataRow("minimal", "minimal")]
        [DataRow("cdata", "cdata")]
        [DataRow("pending", "Pending steps")]
        [DataRow("empty", "Empty Scenarios")]
        [DataRow("examples-tables", "Examples Tables")]
        [DataRow("data-tables", "Data Tables")]
        [DataRow("hooks", "Hooks")]
        [DataRow("parameter-types", "Parameter Types")]
        [DataRow("undefined", "Undefined steps")]
        [DataRow("stack-traces", "Stack traces")]
        [DataRow("rules", "Usage of a `Rule`")]
        // These CCK scenario examples produce Cucumber Messages that are materially compliant with the CCK.
        // The messages produced match the CCK expected messages, with exceptions for things
        // that are not material to the CCK spec (such as IDs don't have to be generated in the same order, timestamps don't have to match, etc.)
        // The rules for what must match and what is allowed to not match are built in to a series of custom FluentAssertion validation rules
        // (located in the CucumberMessagesValidator class)
        public void CCKScenarios(string testName, string featureNameText)
        {
            ResetCucumberMessages(featureNameText + ".ndjson");
            EnableCucumberMessages();
            SetCucumberMessagesOutputFileName(featureNameText + ".ndjson");

            CucumberMessagesAddConfigurationFile("reqnroll.json");
            AddUtilClassWithFileSystemPath();

            var featureFileName = testName.Replace("-", "_");

            AddFeatureFileFromResource($"{featureFileName}/{featureFileName}.feature", "CucumberMessages.Tests.Samples", Assembly.GetExecutingAssembly());
            AddBindingClassFromResource($"{featureFileName}/{featureFileName}.cs", "CucumberMessages.Tests.Samples", Assembly.GetExecutingAssembly());
            //AddBinaryFilesFromResource($"{testName}", "CucumberMessages.CompatibilityTests.CCK", Assembly.GetExecutingAssembly());

            ExecuteTests();

            var validator = new CucumberMessagesValidator(GetActualResults(testName, featureNameText).ToList(), GetExpectedResults(testName, featureFileName).ToList());
            validator.ShouldPassBasicStructuralChecks();
            validator.ResultShouldPassAllComparisonTests();
            validator.ResultShouldPassSanityChecks();

            // This is necessary b/c the System Test framework doesn't understand Rules and can't determine the number of expected tests
            ConfirmAllTestsRan(testName == "rules" ? 3 : null);
        }

        [TestMethod]
        [DataRow("ambiguous", "ambiguous")]
        [DataRow("background", "background")]
        // These tests are not (yet) within the CCK but are included here to round out the testing. The expected results were generated by the CucumberMessages plugin.
        // Once the CCK includes these scenarios, the expected results should come from the CCK repo.
        public void NonCCKScenarios(string testName, string featureNameText)
        {
            CCKScenarios(testName, featureNameText);
        }

        [Ignore]
        [TestMethod]
        [DataRow("attachments", "Attachments")]
        [DataRow("skipped", "Skipping scenarios")]
        [DataRow("unknown-parameter-type", "Unknown Parameter Types")]
        // These scenarios are from the CCK, but Reqnroll cannot provide a compliant implementation. This is usually the result of differences in behavior or support of Gherkin features.
        // When these scenarios are run, expect them to fail.
        public void NonCompliantCCKScenarios(string testName, string featureNameText)
        {
            CCKScenarios(testName, featureNameText);
        }

        [TestMethod]
        //[DataRow("xRetry")] // xRetry currently fails this test because it retries a scenario with an undefined step (which is not expected behavior)
        [DataRow("NUnitRetry")]
        // These tests attempt to execute the Retry scenario from the CCK using the known open-source plugins for Reqnroll that integrate Retry functionality into Reqnroll.
        public void CCKRetryScenario(string pluginName)
        {
            var (plugin, version, unitTestProvider) = pluginName switch
            {
                "NUnitRetry" => ("NUnitRetry.ReqnrollPlugin", "1.0.100", UnitTestProvider.NUnit4),
                "xRetry" => ("xRetry.Reqnroll", "1.0.0", UnitTestProvider.xUnit),
                _ => throw new NotImplementedException("unknown plugin name")
            };

            _testRunConfiguration.UnitTestProvider = unitTestProvider;
            _projectsDriver.AddNuGetPackage(plugin, version);
            var testName = $"retry-{pluginName}";
            CCKScenarios(testName, testName);

        }
    }

}