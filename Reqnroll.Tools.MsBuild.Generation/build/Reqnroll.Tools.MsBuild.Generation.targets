<Project>

  <PropertyGroup>
    <_ReqnrollToolsMsBuildGenerationImported>true</_ReqnrollToolsMsBuildGenerationImported>
  </PropertyGroup>

  <UsingTask
    TaskName="Reqnroll.Tools.MsBuild.Generation.GenerateFeatureFileCodeBehindTask"
    AssemblyFile="$(ReqnrollGenerationTasksAssemblyPath)"
    TaskFactory="$(ReqnrollGenerationTaskFactory)" />
  
  <UsingTask
    TaskName="Reqnroll.Tools.MsBuild.Generation.ReplaceTokenInFileTask"
    AssemblyFile="$(ReqnrollGenerationTasksAssemblyPath)"
    TaskFactory="$(ReqnrollGenerationTaskFactory)" />

  <PropertyGroup Condition="'$(BuildServerMode)' == ''">
    <BuildServerMode Condition="'$(BuildingInsideVisualStudio)'=='true'">false</BuildServerMode>
    <BuildServerMode Condition="'$(BuildingInsideVisualStudio)'!='true'">true</BuildServerMode>
  </PropertyGroup>

  <PropertyGroup>
    <CleanDependsOn>
      CleanFeatureFilesInProject;
      CleanObsoleteCodeBehindFilesInProject;
      $(CleanDependsOn)
    </CleanDependsOn>
  </PropertyGroup>

  <!--
    Show code-behind files as nested items under feature files in Visual Studio Solution Explorer
  -->
  <ItemGroup Condition="'$(ReqnrollUseIntermediateOutputPathForCodeBehind)'!='true'">
    <Compile Update="@(ReqnrollFeatureFiles->'%(CodeBehindFile)')" DependentUpon="%(Filename)" />
  </ItemGroup>

  <Target Name="WarnForObsoleteReqnrollCodeBehindFiles" AfterTargets="CoreCompile"
          Condition="'$(ReqnrollWarnForObsoleteCodeBehindFiles)' == 'true' and '@(ReqnrollObsoleteCodeBehindFiles)' != ''">
    <Warning Text="For code-behind file '@(ReqnrollObsoleteCodeBehindFiles)', no feature file was found. Set project property 'ReqnrollDeleteObsoleteCodeBehindFilesOnClean' to delete these files automatically on 'Clean' or 'Rebuild'." File="@(ReqnrollObsoleteCodeBehindFiles)" Condition="'$(ReqnrollDeleteObsoleteCodeBehindFilesOnClean)' != 'true'" />
    <Warning Text="For code-behind file '@(ReqnrollObsoleteCodeBehindFiles)', no feature file was found. Perform a 'Clean' or 'Rebuild' operation to get these obsolete files deleted." File="@(ReqnrollObsoleteCodeBehindFiles)" Condition="'$(ReqnrollDeleteObsoleteCodeBehindFilesOnClean)' == 'true'" />
  </Target>

  <Target Name="WarnForLegacyReqnrollCodeBehindFiles" AfterTargets="CoreCompile"
          Condition="'$(ReqnrollUseIntermediateOutputPathForCodeBehind)'=='true' and '@(ReqnrollLegacyCodeBehindFiles)' != ''">

    <Warning Text="Old code-behind files found in project folder, although Reqnroll is configured to store them in the 'obj' folder. Perform a 'Clean' or 'Rebuild' operation to get these old files deleted or set 'ReqnrollUseIntermediateOutputPathForCodeBehind' to 'false' to keep the code-behind files in the project folder. ('@(ReqnrollLegacyCodeBehindFiles)')" />
  </Target>

  <Target Name="ProcessReqnrollFeatureFilesInProject"
          BeforeTargets="BeforeCompile;CoreCompile;AssignTargetPaths"
          DependsOnTargets="PrepareForBuild;CoreProcessReqnrollFeatureFilesInProject;IncludeProcessedReqnrollItemsToBuildInputs" />

  <!--
    To regenerate code-behind files when core project settings or Reqnroll dependencies change, we create a cache file with a hash of relevant inputs.
    We only change the file if the hash changes, so that MSBuild incremental build can work properly.
  -->
  <Target Name="ReqnrollCreateProcessFeatureFileInputsCacheFile">
    <PropertyGroup>
      <ReqnrollProcessFeatureFileInputsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectName).ProcessFeatureFileInputs.cache</ReqnrollProcessFeatureFileInputsCacheFile>
    </PropertyGroup>

    <ItemGroup>
      <ReqnrollProcessFeatureFileInputs Include="ProjectName">
        <_ParameterValue>$(MSBuildProjectName)</_ParameterValue>
      </ReqnrollProcessFeatureFileInputs>
      <ReqnrollProcessFeatureFileInputs Include="RootNamespace">
        <_ParameterValue>$(RootNamespace)</_ParameterValue>
      </ReqnrollProcessFeatureFileInputs>
      <ReqnrollProcessFeatureFileInputs Include="ReqnrollVersion">
        <_ParameterValue>@(ReferencePath->WithMetadataValue('NuGetPackageId', 'Reqnroll')->'%(NuGetPackageVersion)')</_ParameterValue>
      </ReqnrollProcessFeatureFileInputs>
      <ReqnrollProcessFeatureFileInputs Include="ReqnrollAssemlyTimestamp">
        <_ParameterValue>@(ReferencePath->WithMetadataValue('NuGetPackageId', 'Reqnroll')->'%(ModifiedTime)')</_ParameterValue>
      </ReqnrollProcessFeatureFileInputs>
      <ReqnrollProcessFeatureFileInputs Include="ReqnrollGeneratorAssemlyTimestamp" Condition="Exists('$(ReqnrollGenerationTasksAssemblyPath)')">
        <_ParameterValue>$([System.IO.File]::GetLastWriteTime('$(ReqnrollGenerationTasksAssemblyPath)').ToString("o"))</_ParameterValue>
      </ReqnrollProcessFeatureFileInputs>
    </ItemGroup>

    <Hash ItemsToHash="@(ReqnrollProcessFeatureFileInputs->'%(Identity)%(_ParameterValue)')">
      <Output TaskParameter="HashResult" PropertyName="_ReqnrollProcessFeatureFileInputsHash" />
    </Hash>

    <WriteLinesToFile Lines="$(_ReqnrollProcessFeatureFileInputsHash)" File="$(ReqnrollProcessFeatureFileInputsCacheFile)" Overwrite="True" WriteOnlyWhenDifferent="True" />

    <!-- Ensure that the file is deleted on clean -->
    <ItemGroup>
      <FileWrites Include="$(ReqnrollProcessFeatureFileInputsCacheFile)" />
    </ItemGroup>
  </Target>


  <Target Name="CoreProcessReqnrollFeatureFilesInProject"
          DependsOnTargets="ReqnrollCreateProcessFeatureFileInputsCacheFile"
          Inputs="@(ReqnrollFeatureFiles);$(ReqnrollProcessFeatureFileInputsCacheFile);$(ReqnrollConfigFile)"
          Outputs="@(ReqnrollFeatureFiles -> '%(CodeBehindFile)');@(ReqnrollFeatureFiles -> '%(MessagesFile)')">

    <Message Text="[Reqnroll] FeatureFiles: @(ReqnrollFeatureFiles)" Importance="normal" />

    <Error
      Text="Reqnroll designer code-behind generation is not compatible with MSBuild code-behind generation. The custom tool must be removed from the file. See https://www.reqnroll.net/documentation/Generate-Tests-from-MsBuild"
      File="@(None)"
      Condition="%(None.Extension) == '.feature' AND %(None.Generator) == 'ReqnrollSingleFileGenerator'"/>

    <PropertyGroup Condition="'$(TargetFrameworkVersion)' != ''">
      <ReqnrollTargetFramework>$(TargetFrameworkVersion)</ReqnrollTargetFramework>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFramework)' != ''">
      <ReqnrollTargetFramework>$(TargetFramework)</ReqnrollTargetFramework>
      <ReqnrollTargetFrameworks>$(TargetFramework)</ReqnrollTargetFrameworks>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworks)' != ''">
      <ReqnrollTargetFrameworks>$(TargetFrameworks)</ReqnrollTargetFrameworks>
    </PropertyGroup>

    <GenerateFeatureFileCodeBehindTask
      ProjectPath="$(MSBuildProjectFullPath)"
      OutputPath="$(ReqnrollCodeBehindOutputPath)"
      FeatureFiles="@(ReqnrollFeatureFiles)"
      RootNamespace="$(RootNamespace)"
      GeneratorPlugins="@(ReqnrollGeneratorPlugins)" 
      
      MSBuildVersion="$(MSBuildVersion)"
      AssemblyName="$(AssemblyName)"
      TargetFrameworks="$(ReqnrollTargetFrameworks)"
      TargetFramework="$(ReqnrollTargetFramework)"
      ProjectGuid="$(ProjectGuid)"
      LaunchDebugger="$(ReqnrollDebugMSBuildTask)"
      >

      <Output TaskParameter="GeneratedFiles" ItemName="ReqnrollGeneratedFiles" />
    </GenerateFeatureFileCodeBehindTask>

    <Message Text="[Reqnroll] Generated code-behind file: %(ReqnrollGeneratedFiles.Identity)" Importance="normal" />
    <Message Text="[Reqnroll] Generated messages file: %(ReqnrollGeneratedFiles.MessagesFile)" Condition="'%(ReqnrollGeneratedFiles.MessagesFile)' != ''" Importance="normal" />
  </Target>

  <Target Name="IncludeProcessedReqnrollItemsToBuildInputs" DependsOnTargets="CoreProcessReqnrollFeatureFilesInProject">
    <!-- We need to process the item inclusions in a separate target, because if we process it in the
         target that has inputs/outputs defined the order of the items will be dependent on what has changed 
         (changed items will be processed last).
         This is a problem, because the C# compiler only detects up-to-date state when the order of 
         the Compile items is the same as in the previous build.
    -->

    <!-- Include newly generated code-behind files in the compile item group -->
    <!-- We only do this when the code-behind files are included to the project implicitly (without mentioning them in the project file) -->
    <!-- This is required if the code-behind files are generated to the intermediate output path (obj folder), -->
    <!-- or for SDK-style projects, unless EnableDefaultItems/EnableDefaultCompileItems is disabled by the user  -->
    <ItemGroup Condition="'$(ReqnrollUseIntermediateOutputPathForCodeBehind)'=='true' or ('$(UsingMicrosoftNETSdk)' == 'true' and '$(EnableDefaultItems)' == 'true' and '$(EnableDefaultCompileItems)' == 'true')">

      <!-- if this is the first time generation of code-behind files, we have to manually add them as compile items -->
      <Compile Include="@(ReqnrollFeatureFiles->'%(CodeBehindFile)')"
               Exclude="@(Compile)"/>

      <!-- remove files which got obsolete, typically after rename operation, or getting changes from source control -->
      <Compile Remove="@(ReqnrollObsoleteCodeBehindFiles)" />

      <!-- in case the code-behind files are saved to the obj folder, we remove the legacy code-behind files 
           of the feature files from the project folder to avoid duplication. 
           These files will be deleted on clean. -->
      <Compile Remove="@(ReqnrollFeatureFiles->'%(LegacyCodeBehindFile)')"
               Condition="'$(ReqnrollUseIntermediateOutputPathForCodeBehind)'=='true'"/>
    </ItemGroup>

    <!-- Embed messages files as resource (required for Reqnroll) -->
    <ItemGroup>
      <!-- We need the condition because it can happen that the messages file is not generated, but we still want to be able to run the tests. 
           In this case the task shows a warning anyway. -->
      <EmbeddedResource Include="@(ReqnrollFeatureFiles->'%(MessagesFile)')" Condition="Exists('%(ReqnrollFeatureFiles.MessagesFile)')">
        <LogicalName>%(ReqnrollFeatureFiles.MessagesResourceName)</LogicalName>
      </EmbeddedResource>
    </ItemGroup>

    <!-- Embed feature files as resource, if requested -->
    <ItemGroup Condition="'$(ReqnrollEmbedFeatureFiles)' == 'true'">
      <EmbeddedResource Include="@(ReqnrollFeatureFiles)">
        <LogicalName>%(ReqnrollFeatureFiles.FeatureFileResourceName)</LogicalName>
      </EmbeddedResource>
    </ItemGroup>

  </Target>

  <Target Name="CleanFeatureFilesInProject">
    <!-- remove known code-behind files for existing feature files -->
    <Delete Files="%(ReqnrollFeatureFiles.CodeBehindFile)" ContinueOnError="true" />
    <Delete Files="%(ReqnrollFeatureFiles.MessagesFile)" ContinueOnError="true" />

    <!-- delete legacy code-behind files -->
    <Delete Files="@(ReqnrollLegacyCodeBehindFiles)" ContinueOnError="true" Condition="'$(ReqnrollUseIntermediateOutputPathForCodeBehind)'=='true'" />
    <ItemGroup Condition="'$(ReqnrollUseIntermediateOutputPathForCodeBehind)'=='true'">
      <Compile Remove="@(ReqnrollLegacyCodeBehindFiles)" />
      <ReqnrollLegacyCodeBehindFiles Remove="@(ReqnrollLegacyCodeBehindFiles)" />
    </ItemGroup>
  </Target>

  <Target Name="CleanObsoleteCodeBehindFilesInProject" Condition="'$(ReqnrollDeleteObsoleteCodeBehindFilesOnClean)' == 'true'">
    <!-- remove obsolete code-behind files, scenarios:
         - after rename operation
         - after deletion of a feature file
         - after pulling latest changes from version control with above changes
     -->
    <Delete Files="@(ReqnrollObsoleteCodeBehindFiles)" ContinueOnError="true" />
    <ItemGroup>
      <!-- We need to remove the deleted files from the lists, because otherwise a Visual Studio "rebuild" 
           produces a missing file error as it does not clean the item groups between clean and build. -->
      <Compile Remove="@(ReqnrollObsoleteCodeBehindFiles)" />
      <ReqnrollObsoleteCodeBehindFiles Remove="@(ReqnrollObsoleteCodeBehindFiles)" />
    </ItemGroup>
  </Target>
</Project>