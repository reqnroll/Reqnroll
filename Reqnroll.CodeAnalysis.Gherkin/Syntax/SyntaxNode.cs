using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Diagnostics;
using System.Text;

namespace Reqnroll.CodeAnalysis.Gherkin.Syntax;

/// <summary>
/// Represents a non-terminal node in a Gerkin syntax tree.
/// </summary>
/// <remarks>
/// <para>This class is loosely based around the public interface of Roslyn's syntax tree: 
/// <see cref="Microsoft.CodeAnalysis.SyntaxNode"/>.</para>
/// </remarks>
[DebuggerDisplay("{GetDebuggerDisplay(), nq}")]
public abstract class SyntaxNode
{
    private GherkinSyntaxTree? _syntaxTree;

    /// <summary>
    /// Initializes a new instance of the <see cref="SyntaxNode"/> class which is orphaned.
    /// </summary>
    /// <param name="node">The internal node to encapsulate.</param>
    internal SyntaxNode(InternalNode node)
    {
        InternalNode = node;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SyntaxNode"/> class which is a child of the specified parent node.
    /// </summary>
    /// <param name="node">The inernal node to encapsulate.</param>
    /// <param name="parent">The node which is the parent of this node.</param>
    /// <param name="position">The position of this node.</param>
    internal SyntaxNode(InternalNode node, SyntaxNode? parent, int position)
    {
        Debug.Assert(position >= 0, "Node position cannot be negative");

        InternalNode = node;
        Parent = parent;
        Position = position;
    }

    internal int Position { get; }

    /// <summary>
    /// Gets the syntax tree this node belongs to.
    /// </summary>
    public GherkinSyntaxTree SyntaxTree => _syntaxTree ?? ComputeSyntaxTree();

    /// <summary>
    /// Gets the internal node which this syntax node provides a structured view of.
    /// </summary>
    internal InternalNode InternalNode { get; }

    private GherkinSyntaxTree ComputeSyntaxTree()
    {
        if (Parent != null)
        {
            return Parent.SyntaxTree;
        }

        return new GherkinSyntaxTree(null, this, GherkinParseOptions.Default, string.Empty);
    }

    /// <summary>
    /// Gets the absolute span of this node in characters, including its leading and trailing trivia.
    /// </summary>
    public TextSpan FullSpan => new(Position, InternalNode.FullWidth);

    /// <summary>
    /// Gets the absolute span of this node in characters, not including its leading and trailing trivia.
    /// </summary>
    public TextSpan Span => new(Position + InternalNode.GetLeadingTriviaWidth(), InternalNode.Width);

    /// <summary>
    /// Determines whether this node has any leading trivia.
    /// </summary>
    public bool HasLeadingTrivia => InternalNode.HasLeadingTrivia;

    /// <summary>
    /// Determines whether this node has any leading trivia.
    /// </summary>
    public bool HasTrailingTrivia => InternalNode.HasTrailingTrivia;

    /// <summary>
    /// Gets the node that is the parent of this node.
    /// </summary>
    public SyntaxNode? Parent { get; }

    /// <summary>
    /// Gets a value indicating whether this node or any of its descendant nodes or tokens have diagnostics on them.
    /// </summary>
    public bool HasDiagnostics => InternalNode.ContainsDiagnostics;

    /// <summary>
    /// Gets a value indicating whether the node represents a construct that not actually present in the source code.
    /// Missing nodes are generated by the parser in error scenarios to represent structural syntax that was expected to be 
    /// present in the source code but were actually missing.
    /// </summary>
    public bool IsMissing => InternalNode.IsMissing;

    /// <summary>
    /// Gets the kind of the syntax node.
    /// </summary>
    public SyntaxKind Kind => InternalNode.Kind;

    /// <summary>
    /// Gets a list of the nodes which are children of this node, in prefix document order.
    /// </summary>
    /// <returns>A list of the child nodes, in prefix document order.</returns>
    public IEnumerable<SyntaxNode> ChildNodes()
    {
        throw new NotImplementedException();
    }

    /// <summary>
    /// Gets a list of all the diagnostics in the sub tree that has this node as its root.
    /// </summary>
    /// <returns>A list of the diagnostics in the sub tree.</returns>
    public IEnumerable<Diagnostic> GetDiagnostics() => SyntaxTree.GetDiagnostics(this);

    /// <summary>
    /// Gets the location of this syntax node in the source document.
    /// </summary>
    /// <returns>The location of this syntax node.</returns>
    public Location GetLocation() => SyntaxTree.GetLocation(Span);

    /// <summary>
    /// Gets the position of the specified slot in this syntax node.
    /// </summary>
    /// <param name="slot">The index of the slot.</param>
    /// <returns>The position of the slot.</returns>
    protected int GetSlotPosition(int slot) => Position + InternalNode.GetSlotOffset(slot);

    /// <summary>
    /// Gets the list of syntax trivia which leads this syntax node.
    /// </summary>
    /// <returns>The list of syntax trivia leading this node.</returns>
    public SyntaxTriviaList GetLeadingTrivia() => GetFirstToken().LeadingTrivia;

    /// <summary>
    /// Gets the list of syntax trivia which trails this syntax node.
    /// </summary>
    /// <returns>The list of syntax trivia trailing this node.</returns>
    public SyntaxTriviaList GetTrailingTrivia() => GetLastToken().TrailingTrivia;

    internal static T CloneAsRoot<T>(T node, GherkinSyntaxTree syntaxTree) where T : SyntaxNode
    {
        var clone = (T)node.InternalNode.CreateSyntaxNode();
        clone._syntaxTree = syntaxTree;

        return clone;
    }

    public SyntaxNode WithAdditionalAnnotations(IEnumerable<SyntaxAnnotation> annotations)
    {
        return InternalNode.WithAdditionalAnnotations(annotations).CreateSyntaxNode();
    }

    public ChildSyntaxList ChildNodesAndTokens() => new(this);

    protected TNode GetRequiredSyntaxNode<TNode>(ref TNode? field, int slot) where TNode : SyntaxNode
    {
        if (field == null)
        {
            var node = InternalNode.GetSlot(slot);

            CodeAnalysisDebug.AssertNotNull(node, nameof(node));

            field = (TNode)node!.CreateSyntaxNode(this, Position + InternalNode.GetSlotOffset(slot));
        }

        return field;
    }

    internal TNode? GetSyntaxNode<TNode>(ref TNode? field, int slot) where TNode : SyntaxNode
    {
        if (field == null)
        {
            var node = InternalNode.GetSlot(slot);

            if (node != null)
            {
                field = (TNode)node.CreateSyntaxNode(this, Position + InternalNode.GetSlotOffset(slot));
            }
        }

        return field;
    }

    internal abstract SyntaxNode? GetSlotAsSyntaxNode(int index);

    public SyntaxToken GetFirstToken()
    {
        var child = ChildNodesAndTokens().First();

        if (child.IsToken)
        {
            return child.AsToken();
        }

        if (child.IsNode)
        {
            return child.AsNode()!.GetFirstToken();
        }

        return default;
    }

    public SyntaxToken GetLastToken()
    {
        var child = ChildNodesAndTokens().Last();

        if (child.IsToken)
        {
            return child.AsToken();
        }

        if (child.IsNode)
        {
            return child.AsNode()!.GetLastToken();
        }

        return default;
    }

    public SourceText GetText(Encoding? encoding = null, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)
    {
        var builder = new StringBuilder(InternalNode.FullWidth);
        WriteTo(new StringWriter(builder));
        return new BuiltSourceText(builder, encoding, checksumAlgorithm);
    }

    public virtual void WriteTo(TextWriter writer) => InternalNode.WriteTo(writer);

    /// <summary>
    /// Gets a string representation of the node.
    /// </summary>
    /// <returns>The content of the node.</returns>
    public override string ToString() => InternalNode?.ToString() ?? string.Empty;

    /// <summary>
    /// Gets a string representation of the node, including its leading and trailing trivia.
    /// </summary>
    /// <returns>A string containing the leading trivia, content and trailing trivia of the node.</returns>
    public string ToFullString() => InternalNode?.ToFullString() ?? string.Empty;

    private string GetDebuggerDisplay() => GetType().Name + " " + (Kind.ToString()) + " " + ToString();
}
