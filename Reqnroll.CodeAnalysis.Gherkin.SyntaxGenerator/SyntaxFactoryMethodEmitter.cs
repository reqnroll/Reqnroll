namespace Reqnroll.CodeAnalysis.Gherkin.SyntaxGenerator;

internal class SyntaxFactoryMethodEmitter(SyntaxNodeClassInfo2 classInfo)
{
    public string EmitSyntaxFactoryMethod()
    {
        var builder = new CSharpBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");

        builder.AppendLine();

        builder.AppendLine("using Reqnroll.CodeAnalysis.Gherkin.Syntax;");
        builder.AppendLine();

        builder.AppendLine("namespace Reqnroll.CodeAnalysis.Gherkin;");

        builder.AppendLine("public static partial class SyntaxFactory");
        builder.AppendBodyBlock(builder =>
        {
            AppendFullFactoryMethodTo(builder);
        });

        return builder.ToString();
    }

    private void AppendFullFactoryMethodTo(CSharpBuilder builder)
    {
        builder
            .Append("public static ")
            .Append(classInfo.ClassName)
            .Append(' ')
            .Append(classInfo.SyntaxKind.Name)
            .AppendLine('(');

        builder.BeginBlock();

        var first = true;

        foreach (var property in classInfo.SlotProperties)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                builder.AppendLine(',');
            }

            builder.Append(property.TypeName);

            if (property.NodeType == SyntaxNodeType.SyntaxNode)
            {
                builder.Append('?');
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name));
        }

        builder.AppendLine(')');
        builder.EndBlock();

        builder.AppendBodyBlock(builder =>
        {
            foreach (var property in classInfo.SlotProperties)
            {
                var argumentName = NamingHelper.PascalCaseToCamelCase(property.Name);

                if (property.NodeType == SyntaxNodeType.SyntaxToken)
                {
                    builder
                        .Append("if (")
                        .Append(argumentName)
                        .Append(".Kind != SyntaxKind.")
                        .Append(property.SyntaxKind.Name)
                        .AppendLine(')');
                    builder.AppendBodyBlock(builder =>
                    {
                        builder
                            .Append("throw new ArgumentException(SyntaxFactoryExceptionMessages.TokenMustBe")
                            .Append(property.SyntaxKind.Name)
                            .Append(", nameof(")
                            .Append(argumentName)
                            .AppendLine("));");
                    });

                    builder.AppendLine();
                }
            }

            builder.AppendLine("return new(");
            builder.BeginBlock();

            builder.Append("InternalSyntaxFactory.").Append(classInfo.SyntaxKind.Name).AppendLine('(');

            builder.BeginBlock();

            var first = true;
            foreach (var property in classInfo.SlotProperties)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    builder.AppendLine(',');
                }

                builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name));

                if (property.NodeType == SyntaxNodeType.SyntaxNode)
                {
                    builder.Append('?');
                }

                builder.Append(".InternalNode");

                if (property.NodeType == SyntaxNodeType.SyntaxToken)
                {
                    builder.Append('!');
                }
            }

            builder.AppendLine("));");

            builder.EndBlock();
            builder.EndBlock();
        });
    }
}
