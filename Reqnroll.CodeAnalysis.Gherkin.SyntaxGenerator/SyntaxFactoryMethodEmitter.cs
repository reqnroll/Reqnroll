namespace Reqnroll.CodeAnalysis.Gherkin.SyntaxGenerator;

internal class SyntaxFactoryMethodEmitter(SyntaxNodeClassInfo classInfo)
{
    public string EmitSyntaxFactoryMethod()
    {
        var builder = new CSharpBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");

        builder.AppendLine();

        builder.AppendLine("using Reqnroll.CodeAnalysis.Gherkin.Syntax;");
        builder.AppendLine();

        builder.AppendLine("namespace Reqnroll.CodeAnalysis.Gherkin;");

        builder.AppendLine("public static partial class SyntaxFactory");
        builder.AppendBodyBlock(builder =>
        {
            AppendFullFactoryMethodTo(builder);
        });

        return builder.ToString();
    }

    private void AppendFullFactoryMethodTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <summary>");
        builder.Append("/// Creates a new <see cref=\"").Append(classInfo.ClassName).AppendLine("\"/> instance,");
        builder.Append("/// specifying all syntax nodes required to compose ")
            .Append(classInfo.SyntaxKind.Name).AppendLine(" syntax.");
        builder.AppendLine("/// </summary>");

        foreach (var property in classInfo.SlotProperties)
        {
            builder
                .Append("/// <param name=\"")
                .Append(NamingHelper.PascalCaseToCamelCase(property.Name))
                .Append("\">")
                .Append(DescriptionHelper.DescribeSlot(property))
                .AppendLine("</param>");
        }

        builder
            .Append("/// <returns>A new <see cref=\"")
            .Append(classInfo.ClassName)
            .AppendLine("\"/> instance.</returns>");

        builder
            .Append("public static ")
            .Append(classInfo.ClassName)
            .Append(' ')
            .Append(classInfo.SyntaxKind.Name)
            .AppendLine('(');

        builder.BeginBlock();

        var first = true;
        var hasRequiredFollowingSlot = true;

        for (var i = 0; i < classInfo.SlotProperties.Length; i++)
        {
            var property = classInfo.SlotProperties[i];

            if (first)
            {
                first = false;
            }
            else
            {
                builder.AppendLine(',');
            }

            builder.Append(property.TypeName);

            if (property.NodeType == SyntaxNodeType.SyntaxNode)
            {
                builder.Append('?');
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name));

            // If the property is optional and there are no required properties following it,
            // we can make the parameter optional.
            if (!property.IsRequired)
            {
                if (hasRequiredFollowingSlot)
                {
                    hasRequiredFollowingSlot = classInfo.SlotProperties
                        .Skip(i + 1)
                        .Any(property => property.IsRequired);
                }

                if (!hasRequiredFollowingSlot)
                {
                    builder.Append(" = default");
                }
            }
        }

        builder.AppendLine(')');
        builder.EndBlock();

        builder.AppendBodyBlock(builder =>
        {
            foreach (var property in classInfo.SlotProperties)
            {
                var argumentName = NamingHelper.PascalCaseToCamelCase(property.Name);

                if (property.NodeType == SyntaxNodeType.SyntaxToken)
                {
                    builder
                        .Append("if (")
                        .Append(argumentName)
                        .Append(".Kind != SyntaxKind.")
                        .Append(property.SyntaxKind.Name)
                        .AppendLine(')');
                    builder.AppendBodyBlock(builder =>
                    {
                        builder
                            .Append("throw new ArgumentException(SyntaxFactoryExceptionMessages.TokenMustBe")
                            .Append(property.SyntaxKind.Name)
                            .Append(", nameof(")
                            .Append(argumentName)
                            .AppendLine("));");
                    });

                    builder.AppendLine();
                }
            }

            builder.AppendLine("return new(");
            builder.BeginBlock();

            builder.Append("InternalSyntaxFactory.").Append(classInfo.SyntaxKind.Name).AppendLine('(');

            builder.BeginBlock();

            var first = true;
            foreach (var property in classInfo.SlotProperties)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    builder.AppendLine(',');
                }

                builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name));

                if (property.NodeType == SyntaxNodeType.SyntaxNode)
                {
                    builder.Append('?');
                }

                builder.Append(".InternalNode");

                if (property.NodeType == SyntaxNodeType.SyntaxToken)
                {
                    builder.Append('!');
                }
            }

            builder.AppendLine("));");

            builder.EndBlock();
            builder.EndBlock();
        });
    }
}
