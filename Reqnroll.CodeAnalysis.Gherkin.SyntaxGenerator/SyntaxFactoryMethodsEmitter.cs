
using System.Collections.Immutable;
using System.Reflection.Metadata;

namespace Reqnroll.CodeAnalysis.Gherkin.SyntaxGenerator;

internal class SyntaxFactoryMethodsEmitter(SyntaxNodeClassInfo classInfo)
{
    private static int GetLastRequiredSlotIndex(SyntaxSlotPropertyInfo[] slotProperties)
    {
        for (var i = slotProperties.Length - 1; i > -1; i--)
        {
            if (slotProperties[i].IsRequired)
            {
                return i;
            }
        }

        return 0;
    }

    public string EmitSyntaxFactoryMethod()
    {
        var builder = new CSharpBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");

        builder.AppendLine();

        builder.AppendLine("using Reqnroll.CodeAnalysis.Gherkin.Syntax;");
        builder.AppendLine("using System.Collections.Immutable;");
        builder.AppendLine();

        builder.AppendLine("namespace Reqnroll.CodeAnalysis.Gherkin;");

        builder.AppendLine("public static partial class SyntaxFactory");
        builder.AppendBodyBlock(builder =>
        {
            AppendFullFactoryMethodTo(builder);

            var parameterGroups = classInfo.SlotGroups
                .Distinct()
                .Select(group => group
                    .Select(name => classInfo.SlotProperties.First(prop => prop.Name == name))
                    .ToArray());

            foreach (var group in parameterGroups)
            {
                builder.AppendLine();
                AppendParameterGroupFactoryMethodsTo(builder, group);
            }
        });

        return builder.ToString();
    }

    private void AppendParameterGroupFactoryMethodsTo(CSharpBuilder builder, SyntaxSlotPropertyInfo[] parameters)
    {
        builder.AppendLine("/// <summary>");
        builder.Append("/// Creates a new <see cref=\"").Append(classInfo.ClassName).AppendLine("\"/> instance.");
        builder.AppendLine("/// </summary>");

        foreach (var property in parameters)
        {
            builder
                .Append("/// <param name=\"")
                .Append(NamingHelper.PascalCaseToCamelCase(property.Name))
                .Append("\">")
                .Append(DescriptionHelper.DescribeSlot(property))
                .AppendLine("</param>");
        }

        builder
            .Append("/// <returns>A new <see cref=\"")
            .Append(classInfo.ClassName)
            .AppendLine("\"/> instance.</returns>");

        AppendFactoryMethodTo(builder, parameters);

        if (parameters.Any(parameter => parameter.NodeType == SyntaxNodeType.SyntaxToken || 
            parameter.NodeType == SyntaxNodeType.SyntaxTokenList))
        {
            builder.AppendLine();

            builder.AppendLine("/// <summary>");
            builder.Append("/// Creates a new <see cref=\"").Append(classInfo.ClassName).AppendLine("\"/> instance.");
            builder.AppendLine("/// </summary>");

            foreach (var property in parameters)
            {
                builder
                    .Append("/// <param name=\"")
                    .Append(NamingHelper.PascalCaseToCamelCase(property.Name))
                    .Append("\">")
                    .Append(DescriptionHelper.DescribeSlot(property))
                    .AppendLine("</param>");
            }

            builder
                .Append("/// <returns>A new <see cref=\"")
                .Append(classInfo.ClassName)
                .AppendLine("\"/> instance.</returns>");

            AppendShorthandFactoryMethodTo(builder, parameters);
        }
    }

    private void AppendFactoryMethodTo(CSharpBuilder builder, SyntaxSlotPropertyInfo[] parameters)
    {
        builder
            .Append("public static ")
            .Append(classInfo.ClassName)
            .Append(' ')
            .Append(classInfo.SyntaxKind.Name)
            .AppendLine('(');

        builder.BeginBlock();

        var first = true;
        var lastRequiredSlotIndex = GetLastRequiredSlotIndex(parameters);

        for (var i = 0; i < parameters.Length; i++)
        {
            var property = parameters[i];

            if (first)
            {
                first = false;
            }
            else
            {
                builder.AppendLine(',');
            }

            builder.Append(property.TypeName);

            if (property.NodeType == SyntaxNodeType.SyntaxNode && !property.IsRequired)
            {
                builder.Append('?');
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name));

            // If the property is optional and there are no required properties following it,
            // we can make the parameter optional.
            if (!property.IsRequired && lastRequiredSlotIndex < i)
            {
                builder.Append(" = default");
            }
        }

        builder.AppendLine(')');
        builder.EndBlock();

        builder.AppendBodyBlock(builder =>
        {
            builder.Append("return ").Append(classInfo.SyntaxKind.Name).AppendLine('(');

            builder.BeginBlock();

            var first = true;
            foreach (var property in classInfo.SlotProperties)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    builder.AppendLine(',');
                }

                if (parameters.Contains(property))
                {
                    builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name));
                }
                else
                {
                    switch (property.NodeType)
                    {
                        case SyntaxNodeType.SyntaxToken:
                            builder.Append("Token(SyntaxKind.").Append(property.SyntaxKinds.First().Name).Append(')');
                            break;

                        default:
                            builder.Append("default");
                            break;
                    }
                }
            }

            builder.AppendLine(");");

            builder.EndBlock();
        });
    }

    private void AppendShorthandFactoryMethodTo(CSharpBuilder builder, SyntaxSlotPropertyInfo[] parameters)
    {
        builder
            .Append("public static ")
            .Append(classInfo.ClassName)
            .Append(' ')
            .Append(classInfo.SyntaxKind.Name)
            .AppendLine('(');

        builder.BeginBlock();

        var first = true;
        var lastRequiredSlotIndex = GetLastRequiredSlotIndex(parameters);

        for (var i = 0; i < parameters.Length; i++)
        {
            var property = parameters[i];

            if (first)
            {
                first = false;
            }
            else
            {
                builder.AppendLine(',');
            }

            switch (property.NodeType)
            {
                case SyntaxNodeType.SyntaxToken:
                    builder.Append("string");
                    break;
                case SyntaxNodeType.SyntaxTokenList:
                    builder.Append("SyntaxTokenList");
                    break;
                case SyntaxNodeType.SyntaxList:
                    builder.Append(property.TypeName);
                    break;
                case SyntaxNodeType.SyntaxNode:
                    builder.Append(property.TypeName);
                    if (!property.IsRequired)
                    {
                        builder.Append('?');
                    }
                    break;
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name));

            // If the property is optional and there are no required properties following it,
            // we can make the parameter optional.
            if (!property.IsRequired && lastRequiredSlotIndex < i)
            {
                builder.Append(" = default");
            }
        }

        builder.AppendLine(')');
        builder.EndBlock();

        builder.AppendBodyBlock(builder =>
        {
            builder.Append("return ").Append(classInfo.SyntaxKind.Name).AppendLine('(');

            builder.BeginBlock();

            var first = true;
            foreach (var property in classInfo.SlotProperties)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    builder.AppendLine(',');
                }

                if (parameters.Contains(property))
                {
                    switch (property.NodeType)
                    {
                        case SyntaxNodeType.SyntaxToken:
                            builder
                                .Append("Token(SyntaxKind.")
                                .Append(property.SyntaxKinds.First().Name)
                                .Append(", ")
                                .Append(NamingHelper.PascalCaseToCamelCase(property.Name))
                                .Append(')');
                            break;

                        default:
                            builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name));
                            break;
                    }
                }
                else
                {
                    switch (property.NodeType)
                    {
                        case SyntaxNodeType.SyntaxToken:
                            builder.Append("Token(SyntaxKind.").Append(property.SyntaxKinds.First().Name).Append(')');
                            break;

                        default:
                            builder.Append("default");
                            break;
                    }
                }
            }

            builder.AppendLine(");");

            builder.EndBlock();
        });
    }

    private void AppendFullFactoryMethodTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <summary>");
        builder.Append("/// Creates a new <see cref=\"").Append(classInfo.ClassName).AppendLine("\"/> instance,");
        builder.Append("/// specifying all syntax nodes required to compose ")
            .Append(classInfo.SyntaxKind.Name).AppendLine(" syntax.");
        builder.AppendLine("/// </summary>");

        foreach (var property in classInfo.SlotProperties)
        {
            builder
                .Append("/// <param name=\"")
                .Append(NamingHelper.PascalCaseToCamelCase(property.Name))
                .Append("\">")
                .Append(DescriptionHelper.DescribeSlot(property))
                .AppendLine("</param>");
        }

        builder
            .Append("/// <returns>A new <see cref=\"")
            .Append(classInfo.ClassName)
            .AppendLine("\"/> instance.</returns>");

        builder
            .Append("public static ")
            .Append(classInfo.ClassName)
            .Append(' ')
            .Append(classInfo.SyntaxKind.Name)
            .AppendLine('(');

        builder.BeginBlock();

        var first = true;
        var lastRequiredSlotIndex = GetLastRequiredSlotIndex([.. classInfo.SlotProperties]);

        for (var i = 0; i < classInfo.SlotProperties.Length; i++)
        {
            var property = classInfo.SlotProperties[i];

            if (first)
            {
                first = false;
            }
            else
            {
                builder.AppendLine(',');
            }

            builder.Append(property.TypeName);

            if (property.NodeType == SyntaxNodeType.SyntaxNode && !property.IsRequired)
            {
                builder.Append('?');
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name));

            // If the property is optional and there are no required properties following it,
            // we can make the parameter optional.
            if (!property.IsRequired && lastRequiredSlotIndex < i)
            {
                builder.Append(" = default");
            }
        }

        builder.AppendLine(')');
        builder.EndBlock();

        builder.AppendBodyBlock(builder =>
        {
            foreach (var property in classInfo.SlotProperties)
            {
                var argumentName = NamingHelper.PascalCaseToCamelCase(property.Name);

                if (property.NodeType == SyntaxNodeType.SyntaxToken)
                {
                    AppendSyntaxTokenArgumentCheckTo(builder, property, argumentName);
                }
            }

            builder.AppendLine("return new(");
            builder.BeginBlock();

            builder.Append("InternalSyntaxFactory.").Append(classInfo.SyntaxKind.Name).AppendLine('(');

            builder.BeginBlock();

            var first = true;
            foreach (var property in classInfo.SlotProperties)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    builder.AppendLine(',');
                }

                builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name));

                if (property.NodeType == SyntaxNodeType.SyntaxNode && !property.IsRequired)
                {
                    builder.Append('?');
                }

                builder.Append(".InternalNode");

                if (property.NodeType == SyntaxNodeType.SyntaxToken)
                {
                    builder.Append('!');
                }
            }

            builder.AppendLine("));");

            builder.EndBlock();
            builder.EndBlock();
        });
    }

    private static void AppendSyntaxTokenArgumentCheckTo(
        CSharpBuilder builder,
        SyntaxSlotPropertyInfo property,
        string argumentName)
    {
        if (property.SyntaxKinds.Length == 1)
        {
            var syntaxKind = property.SyntaxKinds[0];

            builder
                .Append("if (")
                .Append(argumentName)
                .Append(".Kind != SyntaxKind.")
                .Append(syntaxKind.Name)
                .AppendLine(')');
            builder.AppendBodyBlock(builder =>
            {
                builder
                    .Append("throw new ArgumentException(SyntaxFactoryExceptionMessages.TokenMustBe")
                    .Append(syntaxKind.Name)
                    .Append(", nameof(")
                    .Append(argumentName)
                    .AppendLine("));");
            });
        }
        else
        {
            builder
                .Append("if (")
                .Append(argumentName)
                .Append(".Kind != SyntaxKind.")
                .Append(property.SyntaxKinds[0].Name)
                .AppendLine(" &&");

            builder.BeginBlock();

            bool secondCondition = true;
            foreach (var syntaxKind in property.SyntaxKinds.Skip(1))
            {
                if (secondCondition)
                {
                    secondCondition = false;
                }
                else
                {
                    builder.AppendLine(" &&");
                }

                builder
                    .Append(argumentName)
                    .Append(".Kind != SyntaxKind.")
                    .Append(syntaxKind.Name);
            }

            builder.AppendLine(')');
            builder.EndBlock();

            builder.AppendBodyBlock(builder =>
            {
                builder.Append("throw new ArgumentException(SyntaxFactoryExceptionMessages.TokenMustBeOneOf");

                foreach (var syntaxKind in property.SyntaxKinds)
                {
                    builder.Append(syntaxKind.Name);
                }

                builder
                    .Append(", nameof(")
                    .Append(argumentName)
                    .AppendLine("));");
            });
        }

        builder.AppendLine();
    }
}
