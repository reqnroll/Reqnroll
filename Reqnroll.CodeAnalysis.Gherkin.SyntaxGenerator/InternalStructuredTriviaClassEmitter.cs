namespace Reqnroll.CodeAnalysis.Gherkin.SyntaxGenerator;

internal class InternalStructuredTriviaClassEmitter(SyntaxNodeClassInfo classInfo)
{
    public const string ClassName = "Internal";

    public string BaseClassName { get; set; } = "InternalStructuredTriviaSyntax";

    public string EmitRawSyntaxNodeClass()
    {
        var builder = new CSharpBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");

        builder.AppendLine("using Microsoft.CodeAnalysis;");
        builder.AppendLine("using System.Collections.Immutable;");

        builder.AppendLine();

        builder.Append("namespace ").Append(classInfo.ClassNamespace).AppendLine(';');

        builder.Append("public partial class ").AppendLine(classInfo.ClassName);
        builder.AppendBodyBlock(AppendInnerNodeClassTo);

        return builder.ToString();
    }

    private void AppendInnerNodeClassTo(CSharpBuilder builder)
    {

        builder.AppendLine("/// <summary>");
        builder.Append("/// Represents the internal state of a ").Append(classInfo.SyntaxKind.Name).AppendLine(" node.");
        builder.AppendLine("/// </summary>");
        builder.Append("internal class ").Append(ClassName).Append(" : ").AppendLine(BaseClassName);
        builder.AppendBodyBlock(builder =>
        {
            AppendSlotFieldsTo(builder);
            builder.AppendLine();

            AppendSlotPopulatingConstructorTo(builder);
            builder.AppendLine();

            AppendDiagnosticsAndAnnotationsConstructorTo(builder);
            builder.AppendLine();

            AppendSlotCountPropertyTo(builder);
            builder.AppendLine();

            AppendGetSlotMethodTo(builder);
            builder.AppendLine();

            AppendWithDiagnosticsMethodTo(builder);
            builder.AppendLine();

            AppendWithAnnotationsMethodTo(builder);
            builder.AppendLine();

            AppendCreateSyntaxNodeMethodTo(builder);
        });
    }

    private void AppendGetSlotMethodTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <inheritdoc />");
        builder.AppendLine("public override InternalNode? GetSlot(int index)");
        builder.AppendBodyBlock(builder =>
        {
            builder.AppendLine("return index switch");
            builder.AppendBlock("{", builder =>
            {
                foreach (var property in classInfo.SlotProperties)
                {
                    builder
                        .Append(property.Index.ToString())
                        .Append(" => ")
                        .Append(NamingHelper.PascalCaseToCamelCase(property.Name))
                        .AppendLine(",");
                }
                builder.AppendLine("_ => null");
            }, "};");
        });
    }

    private void AppendWithAnnotationsMethodTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <inheritdoc />");
        builder.AppendLine("public override InternalNode WithAnnotations(ImmutableArray<SyntaxAnnotation> annotations)");
        builder.AppendBodyBlock(builder =>
        {
            builder.Append("return new ").Append(ClassName).AppendLine('(');
            builder.BeginBlock();

            foreach (var property in classInfo.SlotProperties)
            {
                builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name)).AppendLine(',');
            }

            builder.AppendLine("GetAttachedDiagnostics(),");
            builder.AppendLine("annotations);");

            builder.EndBlock();
        });
    }

    private void AppendWithDiagnosticsMethodTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <inheritdoc />");
        builder.AppendLine("public override InternalNode WithDiagnostics(ImmutableArray<InternalDiagnostic> diagnostics)");
        builder.AppendBodyBlock(builder =>
        {
            builder.Append("return new ").Append(ClassName).AppendLine('(');
            builder.BeginBlock();

            foreach (var property in classInfo.SlotProperties)
            {
                builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name)).AppendLine(',');
            }

            builder.AppendLine("diagnostics,");
            builder.AppendLine("GetAnnotations());");

            builder.EndBlock();
        });
    }

    private void AppendSlotCountPropertyTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <inheritdoc />");
        builder
            .Append("public override int SlotCount => ")
            .Append(classInfo.SlotProperties.Length.ToString())
            .AppendLine(';');
    }

    private void AppendDiagnosticsAndAnnotationsConstructorTo(CSharpBuilder builder)
    {
        builder.Append("private ").Append(ClassName).AppendLine('(');
        builder.BeginBlock();

        foreach (var property in classInfo.SlotProperties)
        {
            builder.Append(BaseClassName);

            if (property.IsInternalNodeNullable)
            {
                builder.Append('?');
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name)).AppendLine(',');
        }

        builder.AppendLine("ImmutableArray<InternalDiagnostic> diagnostics,");
        builder.AppendLine("ImmutableArray<SyntaxAnnotation> annotations) : base(");
        builder.BeginBlock();

        builder.Append("SyntaxKind.").Append(classInfo.SyntaxKind.Name).AppendLine(',');
        builder.AppendLine("diagnostics,");
        builder.AppendLine("annotations)");

        builder.EndBlock();
        builder.EndBlock();

        builder.AppendBodyBlock(AppendSlotAssignmentsFromConstructorArgumentsTo);
    }

    private void AppendSlotAssignmentsFromConstructorArgumentsTo(CSharpBuilder builder)
    {
        var first = true;

        foreach (var property in classInfo.SlotProperties)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                builder.AppendLine();
            }

            var fieldName = NamingHelper.PascalCaseToCamelCase(property.Name);

            builder.Append("this.").Append(fieldName).Append(" = ").Append(fieldName).AppendLine(';');

            if (property.NodeType == SyntaxNodeType.SyntaxToken)
            {
                builder.Append("IncludeChild(").Append(fieldName).AppendLine(");");
            }
            else
            {
                builder.Append("if (").Append(fieldName).AppendLine(" != null)");
                builder.AppendBodyBlock(builder =>
                {
                    builder.Append("IncludeChild(").Append(fieldName).AppendLine(");");
                });
            }
        }
    }

    private void AppendSlotPopulatingConstructorTo(CSharpBuilder builder)
    {
        builder.Append("public ").Append(ClassName).AppendLine('(');
        builder.BeginBlock();

        var first = true;

        foreach (var property in classInfo.SlotProperties)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                builder.AppendLine(',');
            }

            builder.Append(BaseClassName);

            if (property.IsInternalNodeNullable)
            {
                builder.Append('?');
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name));
        }

        builder.AppendLine(") : base(");
        builder.BeginBlock();

        builder.Append("SyntaxKind.").Append(classInfo.SyntaxKind.Name).AppendLine(')');

        builder.EndBlock();
        builder.EndBlock();

        builder.AppendBodyBlock(AppendSlotAssignmentsFromConstructorArgumentsTo);
    }

    private void AppendSlotFieldsTo(CSharpBuilder builder)
    {
        foreach (var property in classInfo.SlotProperties)
        {
            builder.Append("public readonly ").Append(BaseClassName);

            if (property.IsInternalNodeNullable)
            {
                builder.Append('?');
            }

            builder.Append(" ").Append(NamingHelper.PascalCaseToCamelCase(property.Name)).AppendLine(";");
        }
    }

    private void AppendCreateSyntaxNodeMethodTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <inheritdoc />");
        builder.AppendLine("internal override SyntaxNode CreateSyntaxNode(SyntaxNode? parent, int position)");
        builder.AppendBodyBlock(builder =>
        {
            builder.AppendLine("CodeAnalysisDebug.Assert(");
            builder
                .BeginBlock()
                .AppendLine("parent == null,")
                .AppendLine("\"Cannot specify a parent when creating a syntax node from a structured trivia. \" +")
                .AppendLine("\"To specify a parent, instead use CreateStructuredTriviaSyntaxNode(SyntaxTrivia)\");")
                .EndBlock();

            builder.AppendLine();

            builder
                .Append("return new ")
                .Append(classInfo.ClassName)
                .AppendLine("(this, new SyntaxTrivia(default, this, position), position);");
        });
    }
}

