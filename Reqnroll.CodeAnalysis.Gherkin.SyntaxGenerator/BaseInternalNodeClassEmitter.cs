using System.Collections.Generic;

namespace Reqnroll.CodeAnalysis.Gherkin.SyntaxGenerator;

internal class BaseInternalNodeClassEmitter(SyntaxNodeClassInfo classInfo)
{
    public const string ClassName = "Internal";

    public const string InternalNodeClassName = "InternalNode";

    public string EmitRawSyntaxNodeClass()
    {
        var builder = new CSharpBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");

        builder.AppendLine("using Microsoft.CodeAnalysis;");
        builder.AppendLine("using System.Collections.Immutable;");

        builder.AppendLine();

        builder.Append("namespace ").Append(classInfo.ClassNamespace).AppendLine(';');

        builder.Append("public abstract partial class ").AppendLine(classInfo.ClassName);
        builder.AppendBodyBlock(AppendInnerNodeClassTo);

        return builder.ToString();
    }

    private void AppendInnerNodeClassTo(CSharpBuilder builder)
    {

        builder.AppendLine("/// <summary>");
        builder.Append("/// Represents the internal state of a ").Append(classInfo.ClassName).AppendLine(" instance.");
        builder.AppendLine("/// </summary>");

        if (classInfo.BaseClassName != "SyntaxNode")
        {
            builder.Append("new ");
        }

        builder.Append("internal abstract class ").Append(ClassName).Append(" : ");

        if (classInfo.BaseClassName == "SyntaxNode")
        {
            builder.Append(InternalNodeClassName);
        }
        else
        {
            builder.Append(classInfo.BaseClassName).AppendLine(".Internal");
        }

        builder.AppendBodyBlock(builder =>
        {
            AppendSlotFieldsTo(builder);
            builder.AppendLine();

            AppendSlotPopulatingConstructorTo(builder);
            builder.AppendLine();

            AppendDiagnosticsAndAnnotationsConstructorTo(builder);
            builder.AppendLine();

            AppendSlotCountPropertyTo(builder);
            builder.AppendLine();

            AppendGetSlotMethodTo(builder);
        });
    }

    private void AppendGetSlotMethodTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <inheritdoc />");
        builder.AppendLine("public override InternalNode? GetSlot(int index)");
        builder.AppendBodyBlock(builder =>
        {
            builder.AppendLine("return index switch");
            builder.AppendBlock("{", builder =>
            {
                foreach (var property in classInfo.SlotProperties)
                {
                    builder
                        .Append(property.Index.ToString())
                        .Append(" => ")
                        .Append(NamingHelper.PascalCaseToCamelCase(property.Name))
                        .AppendLine(",");
                }
                builder.AppendLine("_ => null");
            }, "};");
        });
    }

    private void AppendSlotCountPropertyTo(CSharpBuilder builder)
    {
        builder.AppendLine("/// <inheritdoc />");
        builder
            .Append("public override int SlotCount => ")
            .Append(classInfo.SlotProperties.Length.ToString())
            .AppendLine(';');
    }

    private void AppendDiagnosticsAndAnnotationsConstructorTo(CSharpBuilder builder)
    {
        builder.Append("protected ").Append(ClassName).AppendLine('(');
        builder.BeginBlock();
        builder.AppendLine("SyntaxKind kind,");

        foreach (var property in classInfo.SlotProperties)
        {
            builder.Append(InternalNodeClassName);

            if (property.IsInternalNodeNullable)
            {
                builder.Append('?');
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name)).AppendLine(',');
        }

        builder.AppendLine("ImmutableArray<InternalDiagnostic> diagnostics,");
        builder.AppendLine("ImmutableArray<SyntaxAnnotation> annotations) : base(");
        builder.BeginBlock();

        builder.AppendLine("kind,");

        foreach (var property in classInfo.SlotProperties.Where(property => property.IsInherited))
        {
            builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name)).AppendLine(',');
        }

        builder.AppendLine("diagnostics,");
        builder.AppendLine("annotations)");

        builder.EndBlock();
        builder.EndBlock();

        builder.AppendBodyBlock(AppendSlotAssignmentsFromConstructorArgumentsTo);
    }

    private void AppendSlotAssignmentsFromConstructorArgumentsTo(CSharpBuilder builder)
    {
        var first = true;

        foreach (var property in classInfo.SlotProperties.Where(property => !property.IsInherited))
        {
            if (first)
            {
                first = false;
            }
            else
            {
                builder.AppendLine();
            }

            var fieldName = NamingHelper.PascalCaseToCamelCase(property.Name);

            builder.Append("this.").Append(fieldName).Append(" = ").Append(fieldName).AppendLine(';');

            if (property.NodeType == SyntaxNodeType.SyntaxToken)
            {
                builder.Append("IncludeChild(").Append(fieldName).AppendLine(");");
            }
            else
            {
                builder.Append("if (").Append(fieldName).AppendLine(" != null)");
                builder.AppendBodyBlock(builder =>
                {
                    builder.Append("IncludeChild(").Append(fieldName).AppendLine(");");
                });
            }
        }
    }

    private void AppendSlotPopulatingConstructorTo(CSharpBuilder builder)
    {
        builder.Append("public ").Append(ClassName).AppendLine('(');
        builder.BeginBlock();

        builder.Append("SyntaxKind kind");

        foreach (var property in classInfo.SlotProperties)
        {
            builder.AppendLine(',');

            builder.Append(InternalNodeClassName);

            if (property.IsInternalNodeNullable)
            {
                builder.Append('?');
            }

            builder.Append(' ').Append(NamingHelper.PascalCaseToCamelCase(property.Name));
        }

        builder.AppendLine(") : base(");
        builder.BeginBlock();
        builder.Append("kind");

        foreach (var property in classInfo.SlotProperties.Where(property => property.IsInherited))
        {
            builder.AppendLine(',');
            builder.Append(NamingHelper.PascalCaseToCamelCase(property.Name));
        }

        builder.AppendLine(')');

        builder.EndBlock();
        builder.EndBlock();

        builder.AppendBodyBlock(AppendSlotAssignmentsFromConstructorArgumentsTo);
    }

    private void AppendSlotFieldsTo(CSharpBuilder builder)
    {
        foreach (var property in classInfo.SlotProperties.Where(property => !property.IsInherited))
        {
            builder.Append("public readonly ").Append(InternalNodeClassName);

            if (property.IsInternalNodeNullable)
            {
                builder.Append('?');
            }

            builder.Append(" ").Append(NamingHelper.PascalCaseToCamelCase(property.Name)).AppendLine(";");
        }
    }
}
